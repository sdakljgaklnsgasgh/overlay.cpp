#include "Interface/Overlay.h"
#include "Configurations/Globals.h"
#include "opus.h"

#define NOMINMAX
#include <Windows.h>
#include <iostream>
#include <fstream>
#include <WinUser.h>
#include <TlHelp32.h>
#include <psapi.h>
#include <chrono>
#include <cmath>
#include <vector>
#include <algorithm>
#include <stdio.h>
#include <string>
#include <commdlg.h>
#include <shellapi.h>
#include <dwmapi.h>

#include "Images/Images.h"

#include <D3dx9tex.h>
#pragma comment(lib, "D3dx9")

#define STB_IMAGE_IMPLEMENTATION
#include "ImGui/stb_image.h"
#include <windowsx.h>

// Particle structure for constellation effect
struct Particle {
    ImVec2 pos;
    ImVec2 vel;
    float size;
    float life;
    std::vector<int> connections; // Indices of connected particles
};

// Global particle system variables
static bool useParticles = false;
static std::vector<Particle> particles;
static const int maxParticles = 50;
static const float maxConnectionDist = 100.0f;

// Original Color struct and HSVtoRGB function
struct Color {
    float r, g, b, a;
    static Color lerp(const Color& a, const Color& b, float t) {
        return { a.r + (b.r - a.r) * t, a.g + (b.g - a.g) * t, a.b + (b.b - a.b) * t, a.a + (b.a - a.a) * t };
    }
    ImVec4 toImVec4() const { return ImVec4(r, g, b, a); }
};

Color HSVtoRGB(float h, float s, float v, float a = 1.0f) {
    Color rgb = { 0, 0, 0, a };
    if (s <= 0.0f) { rgb.r = v; rgb.g = v; rgb.b = v; return rgb; }
    h = std::fmod(h, 360.0f) / 60.0f;
    int i = (int)h;
    float f = h - i;
    float p = v * (1.0f - s);
    float q = v * (1.0f - s * f);
    float t = v * (1.0f - s * (1.0f - f));
    switch (i) {
    case 0: rgb = { v, t, p, a }; break;
    case 1: rgb = { q, v, p, a }; break;
    case 2: rgb = { p, v, t, a }; break;
    case 3: rgb = { p, q, v, a }; break;
    case 4: rgb = { t, p, v, a }; break;
    case 5: rgb = { v, p, q, a }; break;
    }
    return rgb;
}

// Function to initialize or update particle system
void UpdateParticles(float deltaTime, ImVec2 windowSize) {
    if (!useParticles) {
        particles.clear();
        return;
    }

    // Add new particles if needed
    while (particles.size() < maxParticles) {
        Particle p;
        p.pos = ImVec2((float)(rand() % (int)windowSize.x), (float)(rand() % (int)windowSize.y));
        p.vel = ImVec2((float)(rand() % 200 - 100) / 100.0f, (float)(rand() % 200 - 100) / 100.0f);
        p.size = 2.0f + (rand() % 30) / 10.0f;
        p.life = 1.0f;
        particles.push_back(p);
    }

    // Update particles
    for (size_t i = 0; i < particles.size(); i++) {
        Particle& p = particles[i];
        p.pos.x += p.vel.x * deltaTime * 50.0f;
        p.pos.y += p.vel.y * deltaTime * 50.0f;

        // Bounce off edges
        if (p.pos.x < 0 || p.pos.x > windowSize.x) p.vel.x = -p.vel.x;
        if (p.pos.y < 0 || p.pos.y > windowSize.y) p.vel.y = -p.vel.y;

        // Update life
        p.life -= deltaTime * 0.1f;
        if (p.life <= 0.0f) {
            p.pos = ImVec2((float)(rand() % (int)windowSize.x), (float)(rand() % (int)windowSize.y));
            p.vel = ImVec2((float)(rand() % 200 - 100) / 100.0f, (float)(rand() % 200 - 100) / 100.0f);
            p.size = 2.0f + (rand() % 30) / 10.0f;
            p.life = 1.0f;
        }

        // Update connections
        p.connections.clear();
        for (size_t j = 0; j < particles.size(); j++) {
            if (i != j) {
                float dist = sqrt(pow(particles[i].pos.x - particles[j].pos.x, 2) +
                    pow(particles[i].pos.y - particles[j].pos.y, 2));
                if (dist < maxConnectionDist) {
                    p.connections.push_back(j);
                }
            }
        }
    }
}

// Function to draw particles (modified to use white instead of blue)
void DrawParticles(ImDrawList* drawList, ImVec2 windowPos, float time) {
    if (!useParticles || particles.empty()) return;

    // Draw connections
    for (const auto& p : particles) {
        for (int j : p.connections) {
            float alpha = p.life * (1.0f - (sqrt(pow(p.pos.x - particles[j].pos.x, 2) +
                pow(p.pos.y - particles[j].pos.y, 2)) / maxConnectionDist));
            ImVec4 lineColor = ImVec4(1.0f, 1.0f, 1.0f, alpha * 0.3f); // White
            drawList->AddLine(ImVec2(p.pos.x + windowPos.x, p.pos.y + windowPos.y),
                ImVec2(particles[j].pos.x + windowPos.x, particles[j].pos.y + windowPos.y),
                ImGui::ColorConvertFloat4ToU32(lineColor), 1.0f);
        }
    }

    // Draw particles
    for (const auto& p : particles) {
        float pulse = (sin(time * 2.0f + p.pos.x * 0.01f) + 1.0f) * 0.5f;
        ImVec4 color = ImVec4(1.0f, 1.0f, 1.0f, p.life * (0.5f + pulse * 0.3f)); // White
        drawList->AddCircleFilled(ImVec2(p.pos.x + windowPos.x, p.pos.y + windowPos.y),
            p.size, ImGui::ColorConvertFloat4ToU32(color));
    }
}

// Modified EQ calculation function for smoother transitions
float calculate_eq_response(float freq, float lowCutoff, float lowMidCutoff, float midCutoff, float highMidCutoff, float highCutoff, float lowsGain, float lowMidsGain, float midsGain, float highMidsGain, float highsGain, int sampleRate) {
    // Convert frequency to logarithmic scale for better band distribution
    float logFreq = log10(freq);
    float logLowCutoff = log10(lowCutoff);
    float logLowMidCutoff = log10(lowMidCutoff);
    float logMidCutoff = log10(midCutoff);
    float logHighMidCutoff = log10(highMidCutoff);
    float logHighCutoff = log10(highCutoff);

    // Define bandwidth (Q factor) for each band to control overlap
    const float Q = 1.0f; // Lower Q means wider bandwidth and more overlap

    // Calculate response for each band using a bell curve (Gaussian-like) for smoother transitions
    float lowBandResponse = lowsGain * exp(-pow((logFreq - logLowCutoff) / (Q * (logLowMidCutoff - logLowCutoff)), 2));
    float lowMidBandResponse = lowMidsGain * exp(-pow((logFreq - logLowMidCutoff) / (Q * (logMidCutoff - logLowMidCutoff)), 2));
    float midBandResponse = midsGain * exp(-pow((logFreq - logMidCutoff) / (Q * (logHighMidCutoff - logMidCutoff)), 2));
    float highMidBandResponse = highMidsGain * exp(-pow((logFreq - logHighMidCutoff) / (Q * (logHighCutoff - logHighMidCutoff)), 2));
    float highBandResponse = highsGain * exp(-pow((logFreq - logHighCutoff) / (Q * (logHighCutoff - logHighMidCutoff)), 2));

    // Sum the responses
    float totalResponse = lowBandResponse + lowMidBandResponse + midBandResponse + highMidBandResponse + highBandResponse;

    return totalResponse;
}

// Modified EQ visualization function with corrected scaling
void DrawCoolEQVisualization(float lowsGain, float lowMidsGain, float midsGain, float highMidsGain, float highsGain) {
    static float animTime = 0.0f;
    animTime += ImGui::GetIO().DeltaTime * 0.5f;
    const float lowCutoff = 80.0f;
    const float lowMidCutoff = 250.0f;
    const float midCutoff = 1000.0f;
    const float highMidCutoff = 4000.0f;
    const float highCutoff = 12000.0f;
    const int sampleRate = 48000;
    const int numPoints = 250;
    const float minFreq = 20.0f;
    const float maxFreq = 20000.0f;
    ImVec2 windowPos = ImGui::GetCursorScreenPos();
    ImVec2 canvasSize = ImVec2(ImGui::GetContentRegionAvail().x, 200);
    ImGui::Text("EQ Visualization");
    ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(1, 1));
    ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0, 0));
    ImGui::PushStyleColor(ImGuiCol_ChildBg, ImVec4(0.15f, 0.15f, 0.15f, 1.0f));
    ImGui::BeginChild("EQCanvas", canvasSize, true);
    ImDrawList* drawList = ImGui::GetWindowDrawList();
    std::vector<float> frequencies(numPoints);
    std::vector<float> responses(numPoints);
    float logMinFreq = std::log10(minFreq);
    float logMaxFreq = std::log10(maxFreq);
    for (int i = 0; i < numPoints; i++) {
        float t = (float)i / (numPoints - 1);
        float logFreq = logMinFreq + t * (logMaxFreq - logMinFreq);
        frequencies[i] = std::pow(10.0f, logFreq);
        responses[i] = calculate_eq_response(frequencies[i], lowCutoff, lowMidCutoff, midCutoff, highMidCutoff, highCutoff, lowsGain, lowMidsGain, midsGain, highMidsGain, highsGain, sampleRate);
    }
    float minResponse = responses[0];
    float maxResponse = responses[0];
    for (int i = 1; i < numPoints; i++) {
        if (responses[i] < minResponse) minResponse = responses[i];
        if (responses[i] > maxResponse) maxResponse = responses[i];
    }
    // Adjust y-axis scaling to start at 0 and include a reasonable maximum
    minResponse = std::fmin(minResponse, 0.0f); // Ensure y-axis starts at 0
    maxResponse = std::fmax(15.0f, maxResponse * 1.1f); // Ensure reasonable headroom
    ImVec2 canvasTopLeft = ImGui::GetCursorScreenPos();
    ImVec2 canvasBottomRight = ImVec2(canvasTopLeft.x + canvasSize.x, canvasTopLeft.y + canvasSize.y);
    const float gridSize = 30.0f;
    for (float x = std::fmod(canvasTopLeft.x, gridSize); x < canvasBottomRight.x; x += gridSize) {
        drawList->AddLine(ImVec2(x, canvasTopLeft.y), ImVec2(x, canvasBottomRight.y), ImGui::ColorConvertFloat4ToU32(ImVec4(0.2f, 0.2f, 0.2f, 0.4f)));
    }
    for (float y = std::fmod(canvasTopLeft.y, gridSize); y < canvasBottomRight.y; y += gridSize) {
        drawList->AddLine(ImVec2(canvasTopLeft.x, y), ImVec2(canvasBottomRight.x, y), ImGui::ColorConvertFloat4ToU32(ImVec4(0.2f, 0.2f, 0.2f, 0.4f)));
    }
    const int numMarkers = 9;
    const float markerFreqs[] = { 20, 50, 100, 250, 500, 1000, 4000, 5000, 20000 };
    const char* markerLabels[] = { "20Hz", "50Hz", "100Hz", "250Hz", "500Hz", "1kHz", "4kHz", "5kHz", "20kHz" };
    for (int i = 0; i < numMarkers; i++) {
        float t = (std::log10(markerFreqs[i]) - logMinFreq) / (logMaxFreq - logMinFreq);
        float x = canvasTopLeft.x + t * canvasSize.x;
        drawList->AddLine(ImVec2(x, canvasTopLeft.y), ImVec2(x, canvasBottomRight.y), ImGui::ColorConvertFloat4ToU32(ImVec4(0.3f, 0.3f, 0.3f, 0.6f)));
        ImVec2 textSize = ImGui::CalcTextSize(markerLabels[i]);
        drawList->AddText(ImVec2(x - textSize.x / 2, canvasBottomRight.y - textSize.y - 5), ImGui::ColorConvertFloat4ToU32(ImVec4(0.8f, 0.8f, 0.8f, 1.0f)), markerLabels[i]);
    }
    const int numLevels = 5;
    for (int i = 0; i <= numLevels; i++) {
        float level = minResponse + (maxResponse - minResponse) * i / numLevels;
        float y = canvasBottomRight.y - (level - minResponse) / (maxResponse - minResponse) * canvasSize.y;
        drawList->AddLine(ImVec2(canvasTopLeft.x, y), ImVec2(canvasBottomRight.x, y), ImGui::ColorConvertFloat4ToU32(ImVec4(0.3f, 0.3f, 0.3f, 0.6f)));
        char levelLabel[16];
        snprintf(levelLabel, sizeof(levelLabel), "%.1f", level);
        drawList->AddText(ImVec2(canvasTopLeft.x + 5, y - 10), ImGui::ColorConvertFloat4ToU32(ImVec4(0.8f, 0.8f, 0.8f, 1.0f)), levelLabel);
    }
    std::vector<ImVec2> points(numPoints);
    for (int i = 0; i < numPoints; i++) {
        float t = (float)i / (numPoints - 1);
        float x = canvasTopLeft.x + t * canvasSize.x;
        float y = canvasBottomRight.y - ((responses[i] - minResponse) / (maxResponse - minResponse)) * canvasSize.y;
        points[i] = ImVec2(x, y);
    }
    ImGuiStyle& style = ImGui::GetStyle();
    ImVec4 themeColor = ImVec4(1.0f, 1.0f, 1.0f, 1.0f); // Changed to white
    ImVec4 markerColor = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
    for (int i = 0; i < numPoints - 1; i++) {
        ImVec2 p1 = points[i];
        ImVec2 p2 = points[i + 1];
        ImVec2 p3 = ImVec2(p2.x, canvasBottomRight.y);
        ImVec2 p4 = ImVec2(p1.x, canvasBottomRight.y);
        ImVec4 fillColor = themeColor;
        fillColor.w = 0.2f;
        drawList->AddQuadFilled(p1, p2, p3, p4, ImGui::ColorConvertFloat4ToU32(fillColor));
    }
    const float lineThickness = 3.0f;
    for (int i = 0; i < numPoints - 1; i++) {
        ImVec4 lineColor = themeColor;
        for (float glow = lineThickness * 3; glow >= lineThickness; glow -= 1.0f) {
            float alpha = 0.03f * (1.0f - (glow - lineThickness) / (lineThickness * 2));
            ImVec4 glowColor = lineColor;
            glowColor.w = alpha;
            drawList->AddLine(points[i], points[i + 1], ImGui::ColorConvertFloat4ToU32(glowColor), glow);
        }
        ImVec4 solidLineColor = lineColor;
        solidLineColor.w = 0.9f;
        drawList->AddLine(points[i], points[i + 1], ImGui::ColorConvertFloat4ToU32(solidLineColor), lineThickness);
    }
    float lowX = (std::log10(lowCutoff) - logMinFreq) / (logMaxFreq - logMinFreq) * canvasSize.x + canvasTopLeft.x;
    float lowMidX = (std::log10(lowMidCutoff) - logMinFreq) / (logMaxFreq - logMinFreq) * canvasSize.x + canvasTopLeft.x;
    float midX = (std::log10(midCutoff) - logMinFreq) / (logMaxFreq - logMinFreq) * canvasSize.x + canvasTopLeft.x;
    float highMidX = (std::log10(highMidCutoff) - logMinFreq) / (logMaxFreq - logMinFreq) * canvasSize.x + canvasTopLeft.x;
    float highX = (std::log10(highCutoff) - logMinFreq) / (logMaxFreq - logMinFreq) * canvasSize.x + canvasTopLeft.x;
    {
        float yPos = canvasBottomRight.y - ((lowsGain - minResponse) / (maxResponse - minResponse)) * canvasSize.y;
        drawList->AddCircleFilled(ImVec2(lowX, yPos), 6.0f, ImGui::ColorConvertFloat4ToU32(markerColor));
        drawList->AddCircle(ImVec2(lowX, yPos), 8.0f, ImGui::ColorConvertFloat4ToU32(ImVec4(1, 1, 1, 0.5f)), 0, 2.0f);
    }
    {
        float yPos = canvasBottomRight.y - ((lowMidsGain - minResponse) / (maxResponse - minResponse)) * canvasSize.y;
        drawList->AddCircleFilled(ImVec2(lowMidX, yPos), 6.0f, ImGui::ColorConvertFloat4ToU32(markerColor));
        drawList->AddCircle(ImVec2(lowMidX, yPos), 8.0f, ImGui::ColorConvertFloat4ToU32(ImVec4(1, 1, 1, 0.5f)), 0, 2.0f);
    }
    {
        float yPos = canvasBottomRight.y - ((midsGain - minResponse) / (maxResponse - minResponse)) * canvasSize.y;
        drawList->AddCircleFilled(ImVec2(midX, yPos), 6.0f, ImGui::ColorConvertFloat4ToU32(markerColor));
        drawList->AddCircle(ImVec2(midX, yPos), 8.0f, ImGui::ColorConvertFloat4ToU32(ImVec4(1, 1, 1, 0.5f)), 0, 2.0f);
    }
    {
        float yPos = canvasBottomRight.y - ((highMidsGain - minResponse) / (maxResponse - minResponse)) * canvasSize.y;
        drawList->AddCircleFilled(ImVec2(highMidX, yPos), 6.0f, ImGui::ColorConvertFloat4ToU32(markerColor));
        drawList->AddCircle(ImVec2(highMidX, yPos), 8.0f, ImGui::ColorConvertFloat4ToU32(ImVec4(1, 1, 1, 0.5f)), 0, 2.0f);
    }
    {
        float yPos = canvasBottomRight.y - ((highsGain - minResponse) / (maxResponse - minResponse)) * canvasSize.y;
        drawList->AddCircleFilled(ImVec2(highX, yPos), 6.0f, ImGui::ColorConvertFloat4ToU32(markerColor));
        drawList->AddCircle(ImVec2(highX, yPos), 8.0f, ImGui::ColorConvertFloat4ToU32(ImVec4(1, 1, 1, 0.5f)), 0, 2.0f);
    }
    float pulseAlpha = (std::sin(animTime * 3.0f) + 1.0f) * 0.5f * 0.4f + 0.1f;
    ImVec4 borderColor = ImVec4(1.0f, 1.0f, 1.0f, pulseAlpha);
    drawList->AddRect(canvasTopLeft, canvasBottomRight, ImGui::ColorConvertFloat4ToU32(borderColor), 5.0f, ImDrawFlags_RoundCornersAll, 2.0f);
    ImGui::EndChild();
    ImGui::PopStyleColor();
    ImGui::PopStyleVar(2);
}

static bool showEQVisualization = true;

// Modified EQ controls function with more reasonable gain range
void RenderEQControls() {
    ImGui::PushStyleColor(ImGuiCol_Header, ImVec4(0.1f, 0.1f, 0.1f, 1.0f));
    ImGui::PushStyleColor(ImGuiCol_HeaderHovered, ImVec4(0.15f, 0.15f, 0.15f, 1.0f));
    ImGui::PushStyleColor(ImGuiCol_HeaderActive, ImVec4(0.1f, 0.1f, 0.1f, 1.0f));
    ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(4, 4));
    ImGui::SliderFloat("Bass", &BassGain, 0.0f, 50.0f, "%.2f"); // Adjusted range
    ImGui::SliderFloat("Low Mids", &LowMidGain, 0.0f, 50.0f, "%.2f"); // Adjusted range
    ImGui::SliderFloat("Mids", &MidGain, 0.0f, 30.0f, "%.2f"); // Adjusted range
    ImGui::SliderFloat("High Mids", &HighMidGain, 0.0f, 50.0f, "%.2f"); // Adjusted range
    ImGui::SliderFloat("Treble", &TrebleGain, 0.0f, 50.0f, "%.2f"); // Adjusted range
    ImGui::Checkbox("Show EQ Visualization", &showEQVisualization);
    if (showEQVisualization) {
        DrawCoolEQVisualization(BassGain, LowMidGain, MidGain, HighMidGain, TrebleGain);
    }
    ImGui::PopStyleVar();
    ImGui::PopStyleColor(3);
}

// Original console creation
void CreateConsole() {
    AllocConsole();
    FILE* f;
    freopen_s(&f, "CONOUT$", "w", stdout);
}

// Original time and visibility variables
static float time_since_start = 0.0f;
static bool ui_visible = true;
static HWND hwnd_global = nullptr;
static int current_hotkey = 0;
static bool waiting_for_key = false;

void UpdateTime() {
    static auto start_time = std::chrono::high_resolution_clock::now();
    auto current_time = std::chrono::high_resolution_clock::now();
    time_since_start = std::chrono::duration<float>(current_time - start_time).count();
}

ImVec4 GetAnimatedColor() {
    return ImVec4(1.0f, 1.0f, 1.0f, 0.9f); // Changed to white accent
}

namespace Spoofing {
    bool ProcessIsolation = false;
    bool Hider = true;
}

// Modified configuration functions to include useParticles
std::wstring ConvertToWide(const char* str) {
    int len = MultiByteToWideChar(CP_UTF8, 0, str, -1, nullptr, 0);
    std::wstring wstr(len, L'\0');
    MultiByteToWideChar(CP_UTF8, 0, str, -1, &wstr[0], len);
    return wstr;
}

void SaveConfiguration(const char* file_path) {
    std::ofstream ofs(file_path, std::ios::binary);
    if (ofs) {
        ofs.write(reinterpret_cast<const char*>(&Gain), sizeof(Gain));
        ofs.write(reinterpret_cast<const char*>(&ExpGain), sizeof(ExpGain));
        ofs.write(reinterpret_cast<const char*>(&Spoofing::ProcessIsolation), sizeof(Spoofing::ProcessIsolation));
        ofs.write(reinterpret_cast<const char*>(&Spoofing::Hider), sizeof(Spoofing::Hider));
        ofs.write(reinterpret_cast<const char*>(&BassGain), sizeof(BassGain));
        ofs.write(reinterpret_cast<const char*>(&LowMidGain), sizeof(LowMidGain));
        ofs.write(reinterpret_cast<const char*>(&MidGain), sizeof(MidGain));
        ofs.write(reinterpret_cast<const char*>(&HighMidGain), sizeof(HighMidGain));
        ofs.write(reinterpret_cast<const char*>(&TrebleGain), sizeof(TrebleGain));
        ofs.write(reinterpret_cast<const char*>(&Pan), sizeof(Pan));
        ofs.write(reinterpret_cast<const char*>(&enableAboveHead), sizeof(enableAboveHead));
        ofs.write(reinterpret_cast<const char*>(&enableInHead), sizeof(enableInHead));
        ofs.write(reinterpret_cast<const char*>(&Wideness), sizeof(Wideness));
        ofs.write(reinterpret_cast<const char*>(&showEQVisualization), sizeof(showEQVisualization));
        ofs.write(reinterpret_cast<const char*>(&useParticles), sizeof(useParticles));
        ofs.close();
    }
}

bool SaveConfigurationWithDialog(HWND hwnd) {
    OPENFILENAMEW ofn;
    wchar_t szFile[260] = L"elemental.cfg";
    ZeroMemory(&ofn, sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwnd;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = sizeof(szFile) / sizeof(*szFile);
    ofn.lpstrFilter = L"Configuration Files (*.cfg)\0*.cfg\0All Files (*.*)\0*.*\0";
    ofn.nFilterIndex = 1;
    ofn.lpstrFileTitle = nullptr;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = nullptr;
    ofn.lpstrDefExt = L"cfg";
    ofn.Flags = OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT;
    if (GetSaveFileNameW(&ofn)) {
        SaveConfiguration(std::string(szFile, szFile + wcslen(szFile)).c_str());
        return true;
    }
    return false;
}

void LoadConfiguration(const char* file_path) {
    std::ifstream ifs(file_path, std::ios::binary);
    if (ifs) {
        ifs.read(reinterpret_cast<char*>(&Gain), sizeof(Gain));
        ifs.read(reinterpret_cast<char*>(&ExpGain), sizeof(ExpGain));
        ifs.read(reinterpret_cast<char*>(&Spoofing::ProcessIsolation), sizeof(Spoofing::ProcessIsolation));
        ifs.read(reinterpret_cast<char*>(&Spoofing::Hider), sizeof(Spoofing::Hider));
        ifs.read(reinterpret_cast<char*>(&BassGain), sizeof(BassGain));
        ifs.read(reinterpret_cast<char*>(&LowMidGain), sizeof(LowMidGain));
        ifs.read(reinterpret_cast<char*>(&MidGain), sizeof(MidGain));
        ifs.read(reinterpret_cast<char*>(&HighMidGain), sizeof(HighMidGain));
        ifs.read(reinterpret_cast<char*>(&TrebleGain), sizeof(TrebleGain));
        ifs.read(reinterpret_cast<char*>(&Pan), sizeof(Pan));
        ifs.read(reinterpret_cast<char*>(&enableAboveHead), sizeof(enableAboveHead));
        ifs.read(reinterpret_cast<char*>(&enableInHead), sizeof(enableInHead));
        ifs.read(reinterpret_cast<char*>(&Wideness), sizeof(Wideness));
        ifs.read(reinterpret_cast<char*>(&showEQVisualization), sizeof(showEQVisualization));
        ifs.read(reinterpret_cast<char*>(&useParticles), sizeof(useParticles));
        ifs.close();
    }
}

bool LoadConfigurationWithDialog(HWND hwnd) {
    OPENFILENAMEW ofn;
    wchar_t szFile[260] = L"";
    ZeroMemory(&ofn, sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwnd;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = sizeof(szFile) / sizeof(*szFile);
    ofn.lpstrFilter = L"Configuration Files (*.cfg)\0*.cfg\0All Files (*.*)\0*.*\0";
    ofn.nFilterIndex = 1;
    ofn.lpstrFileTitle = nullptr;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = nullptr;
    ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;
    if (GetOpenFileNameW(&ofn)) {
        LoadConfiguration(std::string(szFile, szFile + wcslen(szFile)).c_str());
        return true;
    }
    return false;
}

void ToggleWindowVisibility(bool hider) {
    Spoofing::Hider = hider;
    SetWindowDisplayAffinity(hwnd_global, hider ? WDA_EXCLUDEFROMCAPTURE : WDA_NONE);
}

// Original system cleanup functions
void RunElevatedCommand(const char* command) {
    ShellExecuteA(nullptr, "runas", "cmd.exe", command, nullptr, SW_HIDE);
}

void ClearTempFiles() {
    RunElevatedCommand("/c del /q /f /s %temp%\\* & for /d %%p in (%temp%\\*) do rd /s /q \"%%p\"");
}

void ClearRunHistory() {
    RunElevatedCommand("/c reg delete HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RunMRU /f");
}

void ClearJournalTraces() {
    RunElevatedCommand("/c wevtutil cl System & wevtutil cl Application");
}

void ClearRegistryKeys() {
    RunElevatedCommand("/c reg delete HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RecentDocs /f");
}

void ClearTaskManager() {
    RunElevatedCommand("/c reg delete HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\TaskManager /f");
}

void ClearPrefetchTraces() {
    RunElevatedCommand("/c del /q /f /s %SystemRoot%\\Prefetch\\* & for /d %%p in (%SystemRoot%\\Prefetch\\*) do rd /s /q \"%%p\"");
}

void ClearRecycleBin() {
    RunElevatedCommand("/c rd /s /q %SystemDrive%\\$Recycle.Bin");
}

void ClearBrowserCache() {
    RunElevatedCommand("/c del /q /f /s %LocalAppData%\\Google\\Chrome\\User Data\\Default\\Cache\\* & "
        "del /q /f /s %LocalAppData%\\Mozilla\\Firefox\\Profiles\\*\\cache\\* & "
        "del /q /f /s %AppData%\\Microsoft\\Edge\\User Data\\Default\\Cache\\*");
}

ImVec4 HexToColorVec4(unsigned int hex_color, float alpha) {
    ImVec4 color;
    color.x = ((hex_color >> 16) & 0xFF) / 255.0f;
    color.y = ((hex_color >> 8) & 0xFF) / 255.0f;
    color.z = (hex_color & 0xFF) / 255.0f;
    color.w = alpha;
    return color;
}

ImVec4 RGBAtoIV4(float r, float g, float b, float a) {
    float newr = r / 255;
    float newg = g / 255;
    float newb = b / 255;
    float newa = a;
    return ImVec4(newr, newg, newb, newa);
}

void utilities::ui::start() {
    WNDCLASSEXW wc = { sizeof(wc), CS_CLASSDC, WndProc, 0L, 0L, GetModuleHandle(nullptr), nullptr, nullptr, nullptr, nullptr, L"Luna Hook", nullptr };
    RegisterClassExW(&wc);

    hwnd_global = CreateWindowExW(
        WS_EX_TOPMOST | WS_EX_TOOLWINDOW | WS_EX_LAYERED,
        wc.lpszClassName,
        L"a",
        WS_POPUP,
        100, 100, 500, 600,
        nullptr, nullptr, wc.hInstance, nullptr
    );

    SetLayeredWindowAttributes(hwnd_global, 0, 255, LWA_ALPHA);

    if (!CreateDeviceD3D(hwnd_global)) {
        CleanupDeviceD3D();
        ::UnregisterClassW(wc.lpszClassName, wc.hInstance);
        return;
    }

    ShowWindow(hwnd_global, SW_SHOW);
    UpdateWindow(hwnd_global);
    if (current_hotkey != 0) {
        RegisterHotKey(NULL, 1, 0, current_hotkey);
    }
    IMGUI_CHECKVERSION();
    ImGui::CreateContext();
    ImGuiIO& io = ImGui::GetIO(); (void)io;
    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;
    io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad;
    io.ConfigDebugIsDebuggerPresent = false;

    ImGuiStyle& style = ImGui::GetStyle();
    ImGui::GetStyle().WindowRounding = 0.0f;
    ImGui::GetStyle().ChildRounding = 0.0f;
    ImGui::GetStyle().FrameRounding = 0.0f;
    ImGui::GetStyle().GrabRounding = 0.0f;
    ImGui::GetStyle().PopupRounding = 0.0f;
    ImGui::GetStyle().ScrollbarRounding = 0.0f;
    ImGui::GetStyle().TabRounding = 0.0f;

    style.Colors[ImGuiCol_Text] = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
    style.Colors[ImGuiCol_TextDisabled] = ImVec4(0.2745098173618317f, 0.3176470696926117f, 0.4509803950786591f, 1.0f);
    style.Colors[ImGuiCol_WindowBg] = ImVec4(0.0784313753247261f, 0.08627451211214066f, 0.1019607856869698f, 1.0f); // Always use the original dark grayish color
    style.Colors[ImGuiCol_ChildBg] = ImVec4(0.0784313753247261f, 0.08627451211214066f, 0.1019607856869698f, 1.0f);
    style.Colors[ImGuiCol_PopupBg] = ImVec4(0.0784313753247261f, 0.08627451211214066f, 0.1019607856869698f, 1.0f);
    style.Colors[ImGuiCol_Border] = ImVec4(0.1568627506494522f, 0.168627455830574f, 0.1921568661928177f, 1.0f);
    style.Colors[ImGuiCol_BorderShadow] = ImVec4(0.0784313753247261f, 0.08627451211214066f, 0.1019607856869698f, 1.0f);
    style.Colors[ImGuiCol_FrameBg] = ImVec4(0.1120669096708298f, 0.1262156516313553f, 0.1545064449310303f, 1.0f);
    style.Colors[ImGuiCol_FrameBgHovered] = ImVec4(0.1568627506494522f, 0.168627455830574f, 0.1921568661928177f, 1.0f);
    style.Colors[ImGuiCol_FrameBgActive] = ImVec4(0.1568627506494522f, 0.168627455830574f, 0.1921568661928177f, 1.0f);
    style.Colors[ImGuiCol_TitleBg] = RGBAtoIV4(232, 232, 232, 1.0f);
    style.Colors[ImGuiCol_TitleBgActive] = RGBAtoIV4(255, 255, 255, 1.0f);
    style.Colors[ImGuiCol_TitleBgCollapsed] = RGBAtoIV4(117.0f, 6.0f, 6.0f, 1.0f);
    style.Colors[ImGuiCol_MenuBarBg] = ImVec4(0.09803921729326248f, 0.105882354080677f, 0.1215686276555061f, 1.0f);
    style.Colors[ImGuiCol_ScrollbarBg] = ImVec4(0.0470588244497776f, 0.05490196123719215f, 0.07058823853731155f, 1.0f);
    style.Colors[ImGuiCol_ScrollbarGrab] = ImVec4(0.1176470592617989f, 0.1333333402872086f, 0.1490196138620377f, 1.0f);
    style.Colors[ImGuiCol_ScrollbarGrabHovered] = ImVec4(0.1568627506494522f, 0.168627455830574f, 0.1921568661928177f, 1.0f);
    style.Colors[ImGuiCol_ScrollbarGrabActive] = ImVec4(0.1176470592617989f, 0.1333333402872086f, 0.1490196138620377f, 1.0f);
    style.Colors[ImGuiCol_CheckMark] = RGBAtoIV4(232, 232, 232, 1.0f);
    style.Colors[ImGuiCol_SliderGrab] = RGBAtoIV4(232, 232, 232, 1.0f);
    style.Colors[ImGuiCol_SliderGrabActive] = RGBAtoIV4(232, 232, 232, 1.0f);
    style.Colors[ImGuiCol_Button] = ImVec4(0.1176470592617989f, 0.1333333402872086f, 0.1490196138620377f, 1.0f);
    style.Colors[ImGuiCol_ButtonHovered] = ImVec4(0.1821731775999069f, 0.1897992044687271f, 0.1974248886108398f, 1.0f);
    style.Colors[ImGuiCol_ButtonActive] = ImVec4(0.1545050293207169f, 0.1545048952102661f, 0.1545064449310303f, 1.0f);
    style.Colors[ImGuiCol_Header] = ImVec4(0.1414651423692703f, 0.1629818230867386f, 0.2060086131095886f, 1.0f);
    style.Colors[ImGuiCol_HeaderHovered] = ImVec4(0.1072951927781105f, 0.107295036315918f, 0.1072961091995239f, 1.0f);
    style.Colors[ImGuiCol_HeaderActive] = ImVec4(0.0784313753247261f, 0.08627451211214066f, 0.1019607856869698f, 1.0f);
    style.Colors[ImGuiCol_Separator] = ImVec4(0.1293079704046249f, 0.1479243338108063f, 0.1931330561637878f, 1.0f);
    style.Colors[ImGuiCol_SeparatorHovered] = ImVec4(0.1568627506494522f, 0.1843137294054031f, 0.250980406999588f, 1.0f);
    style.Colors[ImGuiCol_SeparatorActive] = ImVec4(0.1568627506494522f, 0.1843137294054031f, 0.250980406999588f, 1.0f);
    style.Colors[ImGuiCol_ResizeGrip] = ImVec4(0.1459212601184845f, 0.1459220051765442f, 0.1459227204322815f, 1.0f);
    style.Colors[ImGuiCol_ResizeGripHovered] = ImVec4(0.9725490212440491f, 1.0f, 0.4980392158031464f, 1.0f);
    style.Colors[ImGuiCol_ResizeGripActive] = ImVec4(0.999999463558197f, 1.0f, 0.9999899864196777f, 1.0f);
    style.Colors[ImGuiCol_Tab] = ImVec4(0.0784313753247261f, 0.08627451211214066f, 0.1019607856869698f, 1.0f);
    style.Colors[ImGuiCol_TabHovered] = ImVec4(0.1176470592617989f, 0.1333333402872086f, 0.1490196138620377f, 1.0f);
    style.Colors[ImGuiCol_TabActive] = ImVec4(0.1176470592617989f, 0.1333333402872086f, 0.1490196138620377f, 1.0f);
    style.Colors[ImGuiCol_TabUnfocused] = ImVec4(0.0784313753247261f, 0.08627451211214066f, 0.1019607856869698f, 1.0f);
    style.Colors[ImGuiCol_TabUnfocusedActive] = ImVec4(0.1249424293637276f, 0.2735691666603088f, 0.5708154439926147f, 1.0f);
    style.Colors[ImGuiCol_PlotLines] = ImVec4(0.5215686559677124f, 0.6000000238418579f, 0.7019608020782471f, 1.0f);
    style.Colors[ImGuiCol_PlotLinesHovered] = ImVec4(0.03921568766236305f, 0.9803921580314636f, 0.9803921580314636f, 1.0f);
    style.Colors[ImGuiCol_PlotHistogram] = ImVec4(0.884120166301727f, 0.7941429018974304f, 0.5615870356559753f, 1.0f);
    style.Colors[ImGuiCol_PlotHistogramHovered] = ImVec4(0.9570815563201904f, 0.9570719599723816f, 0.9570761322975159f, 1.0f);
    style.Colors[ImGuiCol_TableHeaderBg] = ImVec4(0.0470588244497776f, 0.05490196123719215f, 0.07058823853731155f, 1.0f);
    style.Colors[ImGuiCol_TableBorderStrong] = ImVec4(0.0470588244497776f, 0.05490196123719215f, 0.07058823853731155f, 1.0f);
    style.Colors[ImGuiCol_TableBorderLight] = ImVec4(0.0f, 0.0f, 0.0f, 1.0f);
    style.Colors[ImGuiCol_TableRowBg] = ImVec4(0.1176470592617989f, 0.1333333402872086f, 0.1490196138620377f, 1.0f);
    style.Colors[ImGuiCol_TableRowBgAlt] = ImVec4(0.09803921729326248f, 0.105882354080677f, 0.1215686276555061f, 1.0f);
    style.Colors[ImGuiCol_TextSelectedBg] = ImVec4(0.9356134533882141f, 0.9356129765510559f, 0.9356223344802856f, 1.0f);
    style.Colors[ImGuiCol_DragDropTarget] = ImVec4(0.4980392158031464f, 0.5137255191802979f, 1.0f, 1.0f);
    style.Colors[ImGuiCol_NavHighlight] = ImVec4(0.266094446182251f, 0.2890366911888123f, 1.0f, 1.0f);
    style.Colors[ImGuiCol_NavWindowingHighlight] = ImVec4(0.4980392158031464f, 0.5137255191802979f, 1.0f, 1.0f);
    style.Colors[ImGuiCol_NavWindowingDimBg] = ImVec4(0.196078434586525f, 0.1764705926179886f, 0.5450980663299561f, 0.501960813999176f);
    style.Colors[ImGuiCol_ModalWindowDimBg] = ImVec4(0.196078434586525f, 0.1764705926179886f, 0.5450980663299561f, 0.501960813999176f);

    ImFontConfig font_config;
    font_config.PixelSnapH = true;
    font_config.OversampleH = 1;
    font_config.OversampleV = 1;
    io.Fonts->AddFontFromFileTTF("C:\\Windows\\Fonts\\segoeui.ttf", 18.0f, &font_config);
    ImVec4 clear_color = ImVec4(0.0f, 0.0f, 0.0f, 1.0f);
    ImGui_ImplWin32_Init(hwnd_global);
    ImGui_ImplDX9_Init(g_pd3dDevice);
    float last_time = 0.0f;
    LoadConfiguration("config.bin");
    ToggleWindowVisibility(Spoofing::Hider);

    static int CurrentTab = 0;

    bool done = false;

    unsigned char* rgba_data = stbi_load_from_memory(icon_data, sizeof(icon_data), &image_width, &image_height, &channels, 4);

    IDirect3DTexture9* texture = nullptr;
    HRESULT hr = g_pd3dDevice->CreateTexture(
        image_width,
        image_height,
        1,
        D3DUSAGE_DYNAMIC,
        D3DFMT_A8R8G8B8,
        D3DPOOL_DEFAULT,
        &texture,
        nullptr
    );

    if (SUCCEEDED(hr))
    {
        D3DLOCKED_RECT locked_rect;
        hr = texture->LockRect(0, &locked_rect, nullptr, D3DLOCK_DISCARD);

        if (SUCCEEDED(hr))
        {
            unsigned char* dest = (unsigned char*)locked_rect.pBits;
            unsigned char* src = rgba_data;

            for (int y = 0; y < image_height; y++)
            {
                for (int x = 0; x < image_width; x++)
                {
                    dest[0] = src[2];
                    dest[1] = src[1];
                    dest[2] = src[0];
                    dest[3] = src[3];

                    dest += 4;
                    src += 4;
                }

                dest = (unsigned char*)locked_rect.pBits + (y + 1) * locked_rect.Pitch;
            }

            texture->UnlockRect(0);
        }
    }

    stbi_image_free(rgba_data);

    while (!done) {
        MSG msg;
        while (::PeekMessage(&msg, nullptr, 0U, 0U, PM_REMOVE)) {
            ::TranslateMessage(&msg);
            ::DispatchMessage(&msg);
            if (msg.message == WM_QUIT) done = true;
            if (msg.message == WM_HOTKEY && msg.wParam == 1) {
                ui_visible = !ui_visible;
                ShowWindow(hwnd_global, ui_visible ? SW_SHOW : SW_HIDE);
                SaveConfiguration("config.bin");
            }
            if (waiting_for_key && msg.message == WM_KEYDOWN) {
                int new_hotkey = static_cast<int>(msg.wParam);
                UnregisterHotKey(NULL, 1);
                current_hotkey = new_hotkey;
                if (current_hotkey != 0) RegisterHotKey(NULL, 1, 0, current_hotkey);
                waiting_for_key = false;
            }
        }
        if (done) break;
        UpdateTime();
        float delta_time = time_since_start - last_time;
        last_time = time_since_start;
        ImGui_ImplDX9_NewFrame();
        ImGui_ImplWin32_NewFrame();
        ImGui::NewFrame();
        RECT Rect;
        GetClientRect(hwnd_global, &Rect);
        ImVec2 window_size((float)(Rect.right - Rect.left), (float)(Rect.bottom - Rect.top));
        ImGui::SetNextWindowPos(ImVec2(0, 0), ImGuiCond_Always);
        ImGui::SetNextWindowSize(window_size, ImGuiCond_Always);
        if (ui_visible) {
            ImGui::PushStyleColor(ImGuiCol_WindowBg, ImVec4(0.0784313753247261f, 0.08627451211214066f, 0.1019607856869698f, 1.0f)); // Always use the original dark grayish color
            ImGui::Begin("Luna", nullptr, ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoScrollbar);
            ImGui::PopStyleColor();

            // Update and draw particles after ImGui::Begin to ensure correct draw list
            ImDrawList* drawList = ImGui::GetWindowDrawList();
            ImVec2 windowPos = ImGui::GetWindowPos();
            UpdateParticles(delta_time, window_size);
            DrawParticles(drawList, windowPos, time_since_start);

            // Moved content below particle rendering to ensure particles are in the background
            ImGui::Image((ImTextureID)texture, ImVec2(16, 16));
            ImGui::SameLine();
            ImGui::Text("Luna");
            ImGui::Separator();

            // Tab Bar
            if (ImGui::BeginTabBar("MainTabs", ImGuiTabBarFlags_FittingPolicyScroll)) {
                if (ImGui::BeginTabItem("Encoder")) {
                    CurrentTab = 0;
                    ImGui::EndTabItem();
                }
                if (ImGui::BeginTabItem("Effects")) {
                    CurrentTab = 1;
                    ImGui::EndTabItem();
                }
                if (ImGui::BeginTabItem("Decoder")) {
                    CurrentTab = 2;
                    ImGui::EndTabItem();
                }
                if (ImGui::BeginTabItem("Misc")) {
                    CurrentTab = 3;
                    ImGui::EndTabItem();
                }
                if (ImGui::BeginTabItem("Settings")) {
                    CurrentTab = 4;
                    ImGui::EndTabItem();
                }
                ImGui::EndTabBar();
            }

            ImGui::BeginChild("Content", ImVec2(0, 0), true, ImGuiWindowFlags_NoScrollbar);
            ImVec2 contentPos = ImGui::GetWindowPos();
            ImVec2 contentSize = ImGui::GetWindowSize();
            // Removed the white outline around the content area
            // drawList->AddRect(contentPos, ImVec2(contentPos.x + contentSize.x, contentPos.y + contentSize.y),
            //     ImGui::ColorConvertFloat4ToU32(ImVec4(1.0f, 1.0f, 1.0f, 0.7f)), 6.0f, ImDrawFlags_RoundCornersAll, 1.0f);
            switch (CurrentTab) {
            case 0: { // Main
                ImGui::BeginChild("AudioChild", ImVec2(ImGui::GetContentRegionAvail().x, ImGui::GetContentRegionAvail().y));
                {
                    ImGui::Text("Audio");
                    ImGui::Separator();
                    ImGui::SliderFloat("vUnits", &vUnits, 1.0f, 100.0f, "%.1f");
                    ImGui::SliderFloat("Gain", &Gain, 1.0f, 100.0f, "%.1f");
                    ImGui::SliderFloat("Rage Gain", &ExpGain, 1.0f, 100.0f, "%.1f");
                    ImGui::Separator();
                    ImGui::SliderFloat("Bitrate", &Bitrate, 8000.0f, 510000.0f, "%.0f");
                    ImGui::SliderFloat("EnergySL", &energySLStrength, 0.0f, 100.0f, "%.2f");
                    ImGui::SliderFloat("Lowering", &LoweringSlider, 0.0f, 20.0f, "%.2f");
                }
                ImGui::EndChild();
                break;
            }
            case 1: { // Effects
                if (ImGui::CollapsingHeader("Spoofing", ImGuiTreeNodeFlags_DefaultOpen)) {
                    ImGui::Checkbox("HighPass", &enableHighPass);
                    ImGui::Checkbox("Spoof dB", &enableClipping);
                }
                if (ImGui::CollapsingHeader("Filters", ImGuiTreeNodeFlags_DefaultOpen)) {
                    ImGui::Checkbox("Enable Gate", &enableNoiseGate);
                    ImGui::SliderFloat("Noise Gate", &noiseGateStrength, 0.0f, 100.0f, "%.0f");
                    ImGui::Checkbox("Enable AGC", &enableAGC);
                    ImGui::SliderFloat("Automatic Gain Control", &agcStrength, 0.0f, 100.0f, "%.0f");
                    ImGui::Checkbox("Enable VAD", &vadEnabled);
                    ImGui::SliderFloat("VAD", &vadSensitivity, 0.0f, 100.0f, "%.0f");
                }
                if (ImGui::CollapsingHeader("Equalizer", ImGuiTreeNodeFlags_DefaultOpen)) {
                    RenderEQControls();
                }
                if (ImGui::CollapsingHeader("Wider")) {
                    ImGui::SliderFloat("Wideness", &Wideness, 100.0f, 1000.0f, "%.0f");
                }
                if (ImGui::CollapsingHeader("Panning")) {
                    ImGui::Checkbox("Above Head", &enableAboveHead);
                    ImGui::Checkbox("In Head", &enableInHead);
                    ImGui::SliderFloat("Pan", &Pan, -1.00f, 1.00f, "%.2f"); //micDegrade
                }
                if (ImGui::CollapsingHeader("Pitch")) {
                    ImGui::SliderFloat("Pitch Octave", &PitchOctave, -24.0f, 24.0f, "%.1f");
                }
                if (ImGui::CollapsingHeader("Color Noises", ImGuiTreeNodeFlags_DefaultOpen)) {
                    ImGui::SliderFloat("White Noise", &whiteNoiseLevel, 0.0f, 100.0f, "%.0f");
                    ImGui::SliderFloat("Pink Noise", &pinkNoiseLevel, 0.0f, 100.0f, "%.0f");
                    ImGui::SliderFloat("Brown Noise", &brownNoiseLevel, 0.0f, 100.0f, "%.0f");
                    ImGui::SliderFloat("Green Noise", &greenNoiseLevel, 0.0f, 100.0f, "%.0f");

                }
                if (ImGui::CollapsingHeader("Audio")) {
                    static int combo1_current = 0;
                    const char* combo1_items[] = { "5760", "960", "480" };
                    ImGui::Combo("Pacsize", &combo1_current, combo1_items, IM_ARRAYSIZE(combo1_items));
                    static int combo2_current = 0;
                    const char* combo2_items[] = { "4096", "2048", "1024", "512", "128" };
                    ImGui::Combo("Audio Payload", &combo2_current, combo2_items, IM_ARRAYSIZE(combo2_items));
                    static int combo6_current = 9;
                    const char* combo6_items[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9", "10" };
                    ImGui::Combo("Complexity", &combo6_current, combo6_items, IM_ARRAYSIZE(combo6_items));
                    static int combo10_current = 0;
                    const char* combo10_items[] = { "24", "16" };
                    ImGui::Combo("LSB Depth", &combo10_current, combo10_items, IM_ARRAYSIZE(combo10_items));
                    static int combo3_current = 0;
                    const char* combo3_items[] = { "CBR", "VBR" };
                    ImGui::Combo("Encoding Method", &combo3_current, combo3_items, IM_ARRAYSIZE(combo3_items));
                    static int combo4_current = 0;
                    const char* combo4_items[] = { "Celt", "Silk", "Hybrid" };
                    ImGui::Combo("Audio Mode", &combo4_current, combo4_items, IM_ARRAYSIZE(combo4_items));
                    static int combo5_current = 0;
                    const char* combo5_items[] = { "Music", "VOIP" };
                    ImGui::Combo("Audio Application", &combo5_current, combo5_items, IM_ARRAYSIZE(combo5_items));
                    static int combo12_current = 0;
                    const char* combo12_items[] = { "-1", "+1" };
                    ImGui::Combo("Voice Ratio", &combo12_current, combo12_items, IM_ARRAYSIZE(combo12_items));
                    static int combo11_current = 0;
                    const char* combo11_items[] = { "Full Band", "Medium Band", "Narrow Band", "Super Wide Band", "Wide Band" };
                    ImGui::Combo("Bandwidth", &combo11_current, combo11_items, IM_ARRAYSIZE(combo11_items));
                }
                break;
            }
            case 2: { // Decoder
                ImGui::Text("Decoder Settings");
                ImGui::Separator();
                ImGui::Checkbox("Client User Detection", &dbcheck);
                ImGui::Checkbox("Force NOT NATTY", &dbThresholdToggle);
                ImGui::Checkbox("Force Frame Size 480", &forceFrameSize480);
                ImGui::Checkbox("Force Frame Size 5760", &forceFrameSize5760);
                ImGui::Separator();
                ImGui::SliderInt("Analysis Delay", &g_analysisDelayMs, 0, 100, "%d ms");
                ImGui::SliderFloat("dB Threshold", &g_dbThreshold, -10.0f, 10.0f, "%.1f dB");
                break;
            }
            case 3: { // Misc
                ImGui::Text("System Utilities");
                ImGui::Separator();
                if (ImGui::Button("Clear Temp", ImVec2(120, 0))) ClearTempFiles();
                ImGui::SameLine();
                if (ImGui::Button("Clear Run History", ImVec2(120, 0))) ClearRunHistory();
                if (ImGui::Button("Clear Journal Traces", ImVec2(120, 0))) ClearJournalTraces();
                ImGui::SameLine();
                if (ImGui::Button("Clear Registry Keys", ImVec2(120, 0))) ClearRegistryKeys();
                if (ImGui::Button("Clear Task Manager", ImVec2(120, 0))) ClearTaskManager();
                ImGui::SameLine();
                if (ImGui::Button("Clear Prefetch Traces", ImVec2(120, 0))) ClearPrefetchTraces();
                if (ImGui::Button("Clear Recycle Bin", ImVec2(120, 0))) ClearRecycleBin();
                ImGui::SameLine();
                if (ImGui::Button("Clear Browser Cache", ImVec2(120, 0))) ClearBrowserCache();
                ImGui::Separator();
                ImGui::Text("Links");
                if (ImGui::Button("Join Discord", ImVec2(120, 0))) {
                    ShellExecuteA(nullptr, "open", "https://discord.gg/wAgNm9eNnS", nullptr, nullptr, SW_SHOWNORMAL);
                }
                ImGui::SameLine();
                if (ImGui::Button("Download Modules", ImVec2(120, 0))) {
                    ShellExecuteA(nullptr, "open", "https://cdn.discordapp.com/attachments/1351720157252292739/1377547049439989770/discord_voice.rar?ex=68395c2a&is=68380aaa&hm=bb4656d8926a4c33d4cc233a8cf10a4605ccdee7b0f4943958d7afd496eb682e&", nullptr, nullptr, SW_SHOWNORMAL);
                }
                if (ImGui::Button("Download Injector", ImVec2(120, 0))) {
                    ShellExecuteA(nullptr, "open", "https://www.youtube.com", nullptr, nullptr, SW_SHOWNORMAL);
                }
                ImGui::Separator();
                ImGui::Text("Made by Ace & Ascend");
                break;
            }
            case 4: { // Settings
                ImGui::Text("Configuration");
                ImGui::Separator();
                bool hider_changed = ImGui::Checkbox("Hide Window", &Spoofing::Hider);
                if (hider_changed) {
                    ToggleWindowVisibility(Spoofing::Hider);
                    SaveConfiguration("config.bin");
                }
                ImGui::Checkbox("Use Particles", &useParticles);
                ImGui::Text("Hide UI Hotkey:");
                ImGui::SameLine();
                std::string hotkey_label = (waiting_for_key ? "Press a key..." : (current_hotkey == 0 ? "None" : std::string(1, static_cast<char>(current_hotkey))));
                if (ImGui::Button(hotkey_label.c_str(), ImVec2(100, 0))) {
                    waiting_for_key = true;
                }
                ImGui::Separator();
                if (ImGui::Button("Save Config", ImVec2(120, 0))) SaveConfigurationWithDialog(hwnd_global);
                ImGui::SameLine();
                if (ImGui::Button("Load Config", ImVec2(120, 0))) LoadConfigurationWithDialog(hwnd_global);
                ImGui::Separator();
                ImGui::Text("Runtime: %.2f s", time_since_start);
                ImGui::Text("FPS: %.1f", ImGui::GetIO().Framerate);
                break;
            }
            }
            ImGui::EndChild();
            ImGui::End();
        }
        ImGui::EndFrame();
        g_pd3dDevice->SetRenderState(D3DRS_ZENABLE, FALSE);
        g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
        g_pd3dDevice->SetRenderState(D3DRS_SCISSORTESTENABLE, FALSE);
        D3DCOLOR clear_col_dx = D3DCOLOR_RGBA((int)(clear_color.x * clear_color.w * 255.0f), (int)(clear_color.y * clear_color.w * 255.0f), (int)(clear_color.z * clear_color.w * 255.0f), (int)(clear_color.w * 255.0f));
        g_pd3dDevice->Clear(0, nullptr, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, clear_col_dx, 1.0f, 0);
        if (g_pd3dDevice->BeginScene() >= 0) {
            ImGui::Render();
            ImGui_ImplDX9_RenderDrawData(ImGui::GetDrawData());
            g_pd3dDevice->EndScene();
        }
        HRESULT result = g_pd3dDevice->Present(nullptr, nullptr, nullptr, nullptr);
        if (result == D3DERR_DEVICELOST && !g_DeviceLost) {
            g_DeviceLost = true;
            ImGui_ImplDX9_InvalidateDeviceObjects();
            ResetDevice();
            if (g_pd3dDevice->TestCooperativeLevel() != D3D_OK) {
                UnregisterHotKey(NULL, 1);
                ImGui_ImplDX9_Shutdown();
                ImGui_ImplWin32_Shutdown();
                ImGui::DestroyContext();
                CleanupDeviceD3D();
                ::DestroyWindow(hwnd_global);
                ::UnregisterClassW(wc.lpszClassName, wc.hInstance);
                done = true;
            }
            else g_DeviceLost = false;
        }
        else if (result < 0) done = true;
    }
    if (!done) {
        UnregisterHotKey(NULL, 1);
        ImGui_ImplDX9_Shutdown();
        ImGui_ImplWin32_Shutdown();
        ImGui::DestroyContext();
        CleanupDeviceD3D();
        ::DestroyWindow(hwnd_global);
        ::UnregisterClassW(wc.lpszClassName, wc.hInstance);
    }
}

// Original Direct3D functions
bool CreateDeviceD3D(HWND hWnd) {
    if ((g_pD3D = Direct3DCreate9(D3D_SDK_VERSION)) == nullptr) return false;
    ZeroMemory(&g_d3dpp, sizeof(g_d3dpp));
    g_d3dpp.Windowed = TRUE;
    g_d3dpp.SwapEffect = D3DSWAPEFFECT_DISCARD;
    g_d3dpp.BackBufferFormat = D3DFMT_UNKNOWN;
    g_d3dpp.EnableAutoDepthStencil = TRUE;
    g_d3dpp.AutoDepthStencilFormat = D3DFMT_D16;
    g_d3dpp.PresentationInterval = D3DPRESENT_INTERVAL_ONE;
    if (g_pD3D->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, hWnd, D3DCREATE_HARDWARE_VERTEXPROCESSING, &g_d3dpp, &g_pd3dDevice) < 0) return false;
    return true;
}

void CleanupDeviceD3D() {
    if (g_pd3dDevice) { g_pd3dDevice->Release(); g_pd3dDevice = nullptr; }
    if (g_pD3D) { g_pD3D->Release(); g_pD3D = nullptr; }
}

void ResetDevice() {
    ImGui_ImplDX9_InvalidateDeviceObjects();
    HRESULT hr = g_pd3dDevice->Reset(&g_d3dpp);
    if (hr == D3DERR_INVALIDCALL) IM_ASSERT(0);
    ImGui_ImplDX9_CreateDeviceObjects();
}

extern IMGUI_IMPL_API LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

LRESULT WINAPI WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    if (ImGui_ImplWin32_WndProcHandler(hWnd, msg, wParam, lParam)) return true;
    switch (msg) {
    case WM_NCHITTEST:
    {
        LRESULT result = DefWindowProc(hWnd, msg, wParam, lParam);

        POINT pt = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
        ScreenToClient(hWnd, &pt);

        RECT draggable_area = { 0, 0, 500, 25 };

        if (PtInRect(&draggable_area, pt))
        {
            return HTCAPTION;
        }

        return result;
    }
    case WM_SIZE:
        if (wParam == SIZE_MINIMIZED) return 0;
        if (g_pd3dDevice != nullptr && wParam != SIZE_MINIMIZED) {
            g_d3dpp.BackBufferWidth = LOWORD(lParam);
            g_d3dpp.BackBufferHeight = HIWORD(lParam);
            ResetDevice();
        }
        return 0;
    case WM_SYSCOMMAND:
        if ((wParam & 0xff0) == SC_KEYMENU) return 0;
        break;
    case WM_DESTROY:
        ::PostQuitMessage(0);
        return 0;
    }
    return ::DefWindowProc(hWnd, msg, wParam, lParam);
}
